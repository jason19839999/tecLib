1.数据库字段这个Timestamp，实体要用Date. 要不然序列化失败。 注意：定义的实体类必须跟数据库一致

2.D:/timg.jpg 访问本地路径   读取文件
            //File filePic = new File("D:/timg.jpg");
            //FileInputStream is = new FileInputStream(filePic);
            //int i = is.available(); // 得到文件大小
            //byte data1[] = new byte[i];

3.写类实体文件注意： 要把文件建立在jpa扫描路径下面
entity
  mimingstock
  等等

要不然不能创建bin,运行会报错

4.查看异常
  有鼠标悬停到异常对象
  点开 + 号， 查看cause,里面有详细错误信息，很有用
  如果定位具体出错的代码行，要查看exception的stack message。

5.CrudRepository 更新/添加/删除时要加事物标签，否则会报错
 @Query(name = "updateConfirm", value = "update hk_bills set is_confirm = 1 where code = :code ", nativeQuery = true)
 @Modifying
 @Transactional

6.右键 Local History 查看本地修改版本

7.查看字段注释  mysql yog 右键选择表 → 改变表 →再执行查询就有注释了

8.urlEncode 和urlDecode  必须在传参数的时候进行encode，防止特殊字符丢失，然后在服务端decode就可以了。

9.str.substring(start,end) 从0开始 end:不包含截取的部分，所以比如substring(1,6)，截取到6，但是截取的部分不包括第六位。

10.使用内置tomcat启动
启动方式：
①、IDEA中main函数启动 nohup java -cp . :./config/ :./lib/* -Dspring.profiles.active=test-2 
                      com.juniorchina.Application >> serving.log 2 > &1 &
                      注意：:./lib/*  是运行jar包

②、mvn springboot-run 命令 
③、java -jar XXX.jar

11.启动.sh和服务命令(命令参照实例：技术总结→服务被调用文件)
./hk_darkpool.sh start | stop | restart 或者
sh hk_darkpool.sh start | stop | restart

12.-D指定多个环境命令（参照Serving项目）
-Dspring.profiles.active=dev | product | test

13.统一处理总结
   ①ControllerAdvice   jsonp跨域问题解决（JsonpAdvice）/统一异常处理
   ②Aspect  doBefore   用户身份验证
   ③Filler  doFilter   跨域问题解决/版本过滤等等
      
14.同步容器： Vector类似List<>数组/Stack/HashTable，他们内部加了synchronized，所以必然会影响到执行性能。
   本身也不太安全，需要在处理这些时，进行额外的同步
   synchronized(Test.class){
        同步容器处理；
   }
 
15.非同步容器：List/Map/Set/Queue

16.并发容器：ConcurrentHashMap的锁分离技术
             若容器中有多把锁，每一把锁用于锁定容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，
         从而可以有效提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配
         一把锁，当一个线程占用锁并访问其中一个段数据的时候，其他段的数据也能被其他线程访问。

17.Java多线程实现的方式有四种
   concurrent 下面ExecutorService/Callable/FutureTask
   ①.继承Thread类，重写run方法
   ②.实现Runnable接口，重写run方法，实现Runnable接口的实现类的实例对象作为Thread构造函数的target
   ③.通过Callable和FutureTask创建线程 Callable/FutureTask   
         cancel取消任务
   ④.通过线程池创建线程ExecutorService.newFixedThreadPool/newCachedThreadPool/newSingleThreadPool
         shutdown()关闭线程

18.redis心得
    ① 适当考虑应用本机缓存，减少访问redis集群,提高效率


        
如下描述：对于分布式缓存，我们需要在Nginx+Lua应用中进行应用缓存来减少Redis集群的访问冲击；
        即首先查询应用本地缓存，如果命中则直接缓存，如果没有命中则接着查询Redis集群、回源到Tomcat；
        然后将数据缓存到应用本地。




    ② 当然本地缓存只针对热点数据、实时性非常高访问量相当大的数据场景

。

19.服务采用单独部署，所谓的隔离机制，如果一个服务不可用了，不影响其他服务使用，当然这种功能方式增加了运维成本，但是实现了高可用
。

20.jpa多表关联查询sql处理 https://blog.csdn.net/helloworld_dream/article/details/78913008

21. //concurrent包的线程安全Set，用来存放每个客户端对应的MyWebSocket对象。
    //CopyOnWriteArrayList适合使用在读操作远远大于写操作的场景里，比如缓存。发生修改时候做copy，新老版本分离，保证读的高性能，适用于以读为主的情况。
    //     *      对于CopyOnWriteArraySet<E>类： 
    //             *      1）它最适合于具有以下特征的应用程序：set 大小通常保持很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突。  
    //             *      2）它是线程安全的, 底层的实现是CopyOnWriteArrayList；   
    //             *      3）因为通常需要复制整个基础数组，所以可变操作（add、set 和 remove 等等）的开销很大。  
    //             *      4）迭代器不支持可变 remove 操作。  
    //             *      5）使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。  
    //            ---------------------
    //    作者：学无止境qwer
    //    来源：CSDN
    //    原文：https://blog.csdn.net/u012956987/article/details/50811703
    //    版权声明：本文为博主原创文章，转载请附上博文链接！
    public static CopyOnWriteArraySet<WebSocketServer> webSocketSet = new CopyOnWriteArraySet<WebSocketServer>();
    参照代码：\crudreposity实现读写分离和Redis处理（经典）\crudreposity\src\main\java\datacenter\crudreposity\websocket\WebSocketServer.java

22.生产环境问题定位：
  ①.查看应用各项性能指标：CPU、内存、连接数（time_wait，一般最高也就5000左右，一旦超过3000会有慢的情况，要排查是否哪对其有影响）;
  ②.查看mysql各项性能指标：CPU、内存、连接、执行效率低的sql;
  ③.加监控日志，排查具体接口的执行时间；
  ④.基于当前架构，分析可能存在的系统瓶颈；
  ⑤.mysql 死锁问题，事务控制尽量放到mysql端，即放到存储过程里面，减少网络延迟和GC；
  ⑥.查看网络拓扑结构，尽量内网通信；
  ⑦.重要一个宗旨就是减少mysql的访问量；充分利用nosql和缓存服务，其次本地内存也需要考虑；
  ⑧.查看是否被其他业务访问影响，这个也是关键因素。

23.服务器端之间的通信：通过post请求实现，调用websocket所在服务端的接口，来达到通知其他负载上面客户端连接的目的。
 spring boot 
   ①实现 RestTemplate →→ ResponseEntity<StockResponse> response = restTemplate.exchange(uri, HttpMethod.POST, httpEntity, StockResponse.class);
   ②.通过HttpPost   → CloseableHttpClient httpClient = HttpClients.createDefault(); → reponse = httpClient.execute(httppost);

24.redis事务控制：multi   → begin transaction
                   exec   →  commit
                   discard →  rollback
    redis吞吐量指标：
	读取线程数量2 的吞吐量为 4.3/S 平均每个线程读取能力2.1W/S 负载1.0
	读取线程数量4（cpu内核2倍）的吞吐量为 5.6W/S 平均每个线程读取能力 1.4W/S 负载 1.85
	读取线程数量6 (cpu内核3倍) 的吞吐量为 6.3W/S 平均每个线程读取能力 1W/S 负载 2.73
	读取线程数量8 (cpu内核4倍) 的吞吐量为 6.7W/S 平均每个线程读取能力 8300/S 负载3.42
    redis多个实例 →  配置多个端口即可

25.CopyOnWriteArraySet：它最适合于具有以下特征的应用程序：set 大小通常保持很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突。 
	它是线程安全的。 
	因为通常需要复制整个基础数组，所以可变操作（add、set 和 remove 等等）的开销很大。 
	迭代器不支持可变 remove 操作。 
	使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。 
	//迭代器
	Iterator iter = webSocketSet.iterator();
	while(iter.hasNext()) {
	 WebSocketServer item = (WebSocketServer)iter.next();
	try {
		item.sendMessage(message);
	} catch (IOException e) {
        e.printStackTrace();
	 }
	}

26.mongoDB架构：
   replica set 主、副本集，主如果挂了，  副本接替主继续工作
   master-slaver
   sharding

27.①.分布式是指将不同的业务分布在不同的地方。 而集群指的是将几台服务器集中在一起，实现同一业务。
   ②.简单说，分布式是以缩短单个任务的执行时间来提升效率的，而集群则是通过提高单位时间内执行的任务数来提升效率。

28.线程的使用
	wait notify notifyall  object类的方法
	wait方法，使当前线程暂停执行并释放对象锁标志，使其他线程进入syncronized数据区
	当前线程被放入对象等待池中。
	notify 将对象的等待池中取出任意一个线程放到锁标志等待池中，只有锁标志等待池中的
	线程能够获取到锁标志，如果锁标志等待池中没有线程，那么notify不起作用。

	sleep         yield        thread类的方法
	sleep和yield 都没有释放锁标志
	sleep 让不同优先级的线程执行 sleep()高优先级的，这样低优先级的就获得了执行机会
	yield 只能让出cpu占有权，只针对同优先级。找同等级的线程是否有可执行的
	Future是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果的接口。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。

29.hbase特点：列和数据存放格式：byte[]
	列动态增加
	数据自动切分
	高并发读写
	不支持条件查询
	最多支持5个列簇，每个列簇支持百万个列，支持百亿行

30.spring boot 框架版本历史
	版本号               	发布时间	备注
	v0.5.0.M1	        2013-08-06	
	v1.0.0.RELEASE		2014-04-01	
	v1.2.0.RELEASE		2014-12-11	
	v1.3.0.RELEASE		2015-11-16	
	v1.4.0.RELEASE		2016-07-29	
	v1.5.0.RELEASE		2017-01-30	
	v2.0.0.M2	        2017-06-16	最新
