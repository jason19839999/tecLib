1.linux命令：
    ① load average后面三个数字分别代表不同时间段即一分钟、五分钟和十五分钟的系统平均负载；
    ② cat /proc/loadavg 第四个值的分子是正在运行的进程数，分母为总进程数；第五个值是最近运行的进程id；
    ③ ps aux --sort -rss 查看应用内存的使用情况；

2.ExecutorService ThreadPool →  动态维护线程池，什么场景下适合。
     newFixedThreadPool： LinkedBlockingQueue   
     newSingleThreadExecutor：LinkedBlockingQueue 
     newCachedThreadPool：SynchronousQueue

3.研究代码的时候最好看看源码，深入了解下原理

4.mysql的隔离级别，各自优缺点
   事务的基本要素（ACID）
　　 原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，
   会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。
　　 一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。
　　 隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，
   在A取钱的过程结束前，B不能向这张卡转账。
　　 持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。

   事务隔离级别                                   脏读       不可重复读       幻读 
     读未提交（read-uncommitted）                 Y              Y             Y 
     不可重复读（read-committed）		  N              Y             Y 
     可重复读（repeatable-read）		  N              N             Y 
     串行化（serializable）                       N              N             N 

    脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据
　　不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。
　　幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，
  当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。
　　小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，
  解决幻读需要锁表

5.基本数据类型和引用数据类型的区别
   区别:基本数据类型和引用类型的区别主要在于基本数据类型是分配在栈上的，而引用类型是分配在堆上的（需要java中的栈、堆概念），
   猜想：不论是基本数据类型还是引用类型，他们都会先在栈中分配一块内存，对于基本类型来说，这块区域包含的是基本类型的内容；
   而对于对象类型来说，这块区域包含的是指向真正内容的指针，真正的内容被手动的分配在堆上。

6.mysql 索引方式，深入研究，建立索引，在where条件是否生效原理，深入研究； 总体规则就是就近生效原则：
  复合索引顺序：idx_table_name_object_table_name  
      存在断路原则，索引的先后顺序，a b c 如果where 后面没有 a ，则不生效，只要有就行，跟顺序没关系；加上or 都失效，除非每个都建立索引；
    ① 这种情况失效：EXPLAIN SELECT * FROM user_sub_table WHERE table_name LIKE '%user' 
    ② 这种情况失效：EXPLAIN SELECT * FROM user_sub_table WHERE object_table_name LIKE '%aa' AND  table_name LIKE '%user'  
      这种情况生效：EXPLAIN SELECT * FROM user_sub_table WHERE object_table_name LIKE '%aa' AND  table_name LIKE 'user%'  
      这种情况生效：EXPLAIN SELECT * FROM user_sub_table WHERE object_table_name LIKE 'aa%' AND  table_name LIKE 'user%'  
      这种情况失效：EXPLAIN SELECT * FROM user_sub_table WHERE object_table_name LIKE 'aa%' AND  table_name LIKE '%user'  
      这种情况失效：EXPLAIN SELECT * FROM user_sub_table WHERE object_table_name = 'aa%' OR  table_name = 'user%' 

      这种情况生效：EXPLAIN SELECT * FROM user_sub_table WHERE table_name = 'aa' AND  object_table_name = 'user'  
      这种情况生效：EXPLAIN SELECT * FROM user_sub_table WHERE object_table_name = 'aa' AND table_name  = 'user'  

  单键索引：idx_table_name/idx_object_table_name    总体规则就是就近生效原则：
    ①【idx_object_table_name】 EXPLAIN SELECT * FROM user_sub_table WHERE object_table_name LIKE 'aa%'   AND table_name  LIKE 'user%'   
    ②                          EXPLAIN SELECT * FROM user_sub_table WHERE object_table_name LIKE '%aa'   AND table_name  LIKE '%user'  
    ③ 【idx_object_table_name】 EXPLAIN SELECT * FROM user_sub_table WHERE object_table_name LIKE 'aa%'   AND table_name  LIKE '%user'  
    ④ 【idx_table_name】      EXPLAIN SELECT * FROM user_sub_table WHERE object_table_name LIKE '%aa'   AND table_name  LIKE 'user%' 
    ⑤                         EXPLAIN SELECT * FROM user_sub_table WHERE object_table_name LIKE 'aa%' OR table_name  LIKE 'user%'  

    ⑥【table_name】        EXPLAIN SELECT * FROM user_sub_table WHERE table_name = 'aa' AND  object_table_name = 'user'  
    ⑦【object_table_name】 EXPLAIN SELECT * FROM user_sub_table WHERE object_table_name = 'aa' AND table_name  = 'user'  
    ⑧【null】              EXPLAIN SELECT * FROM user_sub_table WHERE object_table_name = 'aa' OR table_name  = 'user'  
    如果出现=号，like也满足条件，那么=号的索引生效
    ⑨【idx_table_name】    EXPLAIN SELECT * FROM user_sub_table WHERE object_table_name LIKE 'aa%' AND table_name  = '%user' 

7.Synchronized 和 ReentrantLock 的区别  深入研究；轮训，可重入，中断，可以设置超时时间，如果超时会回到等待池。
  参照代码：\crudreposity实现读写分离和Redis处理（经典）\crudreposity\src\main\java\datacenter\crudreposity\aspect\LockAspect.java

8.list 和 set 的区别，隐身其他集合的深入研究
        //list  有序连续的可重复数组，读取快，写入慢；

        //set的用法:无序且不能存储相同的元素，读取慢，写入快； https://blog.csdn.net/Dzy_water/article/details/79144206
        //TreeSet         :会将里面的元素默认排序。TreeSet(内部实现二叉树) 主要作用:排序 Comparable，Comparator，compareTo
        //Hashset         :它是无顺序的，利用hash算法给赋值,使用HashSet 主要用来去重,当Set集合在进行存储的时候,hashCode值相同时,
        // 会调用equals方法进行对比是同一个对象就不存;当hashCode值不相同时 不用调用equals方法,可以直接存
        //LinkedHashSet   :有序 怎么存就怎么取出来

	//        看到array，就要想到角标。
	//        看到link，就要想到first，last。
	//        看到hash，就要想到hashCode,equals.
	//        看到tree，就要想到两个接口。Comparable，Comparator
  

9.多线程  深入研究  线程重入，重排序等深入研究 Synchronized和Volatile区别，各自深入研究  看视频

10.分库分表怎么分，深入研究？
   分表→ 按时间分：建立一个字典表，把表的配置写入
         比如：id、表名、开始时间、结束时间、要写入的表名
	 user  user_1  user_2  写一个存储过程根据当前系统时间判断需要插入到哪个表
	 然后插入或者更新就可以了。以后查询也是按照这个规则来。
	 配置表：CREATE TABLE `user_sub_table` (
	  `id` bigint(20) NOT NULL AUTO_INCREMENT,
	  `table_name` varchar(20) DEFAULT NULL,
	  `start_time` datetime DEFAULT NULL,
	  `end_time` datetime DEFAULT NULL,
	  `object_table_name` varchar(20) DEFAULT NULL,
	  PRIMARY KEY (`id`)
	) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=latin1

	id     `table_name`  `start_time`             `end_time`             `object_table_name`
	"1	  user	   2018-11-13 16:57:55	   2018-11-15 16:58:06	          user_1"
	"2	  user	   2018-11-16 16:58:19	   2018-11-17 16:58:27	          user_2"

   分库→ 

11.int 和 Integer的区别

12.hashtable
   Hashtable<String, Integer> table = new Hashtable<String, Integer>();
   ① Hashtable 是一个散列表，它存储的内容是键值对(key-value)映射。
   ② Hashtable 继承于Dictionary，实现了Map、Cloneable、java.io.Serializable接口。
   ③ Hashtable 的函数都是同步的，这意味着它是线程安全的。它的key、value都不可以为null

结论：HashMap对象的key、value值均可为null。它不是线程安全的。           
      HahTable对象的key、value值均不可为null。
      且两者的的key值均不能重复，若添加key相同的键值对，后面的value会自动覆盖前面的value，但不会报错。

13.聚集索引和非聚集索引
   每个表只能有一个聚簇索引，因为一个表中的记录只能以一种物理顺序存放。但是，一个表可以有不止一个非聚簇索引。实际上
   ，对每个表你最多可以建立249个非聚簇索引。非聚簇索引需要大量的硬盘空间和内存。另外，虽然非聚簇索引可以提高从表中
   取数据的速度，它也会降低向表中插入和更新数据的速度。每当你改变了一个建立了非聚簇索引的表中的数据时，必须同时更新索引。
   因此你对一个表建立非聚簇索引时要慎重考虑。如果你预计一个表需要频繁地更新数据，那么不要对它建立太多非聚簇索引。
   另外，如果硬盘和内存空间有限，也应该限制使用非聚簇索引的数量。
    聚簇索引的侯选列
   ①、主键列,该列在where子句中使用并且插入是随机的。
   ②、按范围存取的列，如pri_order > 100 and pri_order < 200。
   ③、在group by或order by中使用的列。
   ④、不经常修改的列。
   ⑤、在连接操作中使用的列。
 
14.aop基于spring什么原理实现的？spring原理？

15.redis 属于单线程，为何高效？如何分片，深入学习？  
   ① 为什么说redis能够快速执行
   (1) 绝大部分请求是纯粹的内存操作（非常快速）
   (2) 采用单线程,避免了不必要的上下文切换和竞争条件
   (3) 非阻塞IO - IO多路复用
   ② redis的内部实现
      内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，
   绝不在io上浪费一点时间 这3个条件不是相互独立的，特别是第一条，如果请求都是耗时的，采用单线程吞吐量及性能可想而知了。应该说redis为
   特殊的场景选择了合适的技术方案。
   ③ Redis关于线程安全问题
     redis实际上是采用了线程封闭的观念，把任务封闭在一个线程，自然避免了线程安全问题，不过对于需要依赖多个redis操作的复合操作来说，依然
     需要锁，而且有可能是分布式锁。

   
16.mongodb 属于多线程 深入学习？

17.java GC1原理 之前的是CMS UseConcMarkSeepGC 原理

18.java 单向链表反转  实现

19.分库分表  分表的思想 → 数据量大的情况：可以存储上ES/lucence上，供查询用，这个想法很好！
                          数据量小的情况：通过配置表按时间拆分；

