1.linux命令：
    ① load average后面三个数字分别代表不同时间段即一分钟、五分钟和十五分钟的系统平均负载；
    ② cat /proc/loadavg 第四个值的分子是正在运行的进程数，分母为总进程数；第五个值是最近运行的进程id；
    ③ ps aux --sort -rss 查看应用内存的使用情况；

2.ExecutorService ThreadPool →  动态维护线程池，什么场景下适合。
     newFixedThreadPool： LinkedBlockingQueue   
     newSingleThreadExecutor：LinkedBlockingQueue 
     newCachedThreadPool：SynchronousQueue

3.研究代码的时候最好看看源码，深入了解下原理

4.mysql的隔离级别，各自优缺点

5.基本数据类型和引用数据类型的区别

6.mysql 索引方式，深入研究，建立索引，在where条件是否生效原理，深入研究； 总体规则就是就近生效原则：
  复合索引顺序：idx_table_name_object_table_name  
      存在断路原则，索引的先后顺序，a b c 如果where 后面没有 a ，则不生效，只要有就行，跟顺序没关系；加上or 都失效，除非每个都建立索引；
    ① 这种情况失效：EXPLAIN SELECT * FROM user_sub_table WHERE table_name LIKE '%user' 
    ② 这种情况失效：EXPLAIN SELECT * FROM user_sub_table WHERE object_table_name LIKE '%aa' AND  table_name LIKE '%user'  
      这种情况生效：EXPLAIN SELECT * FROM user_sub_table WHERE object_table_name LIKE '%aa' AND  table_name LIKE 'user%'  
      这种情况生效：EXPLAIN SELECT * FROM user_sub_table WHERE object_table_name LIKE 'aa%' AND  table_name LIKE 'user%'  
      这种情况失效：EXPLAIN SELECT * FROM user_sub_table WHERE object_table_name LIKE 'aa%' AND  table_name LIKE '%user'  
      这种情况失效：EXPLAIN SELECT * FROM user_sub_table WHERE object_table_name = 'aa%' OR  table_name = 'user%' 

      这种情况生效：EXPLAIN SELECT * FROM user_sub_table WHERE table_name = 'aa' AND  object_table_name = 'user'  
      这种情况生效：EXPLAIN SELECT * FROM user_sub_table WHERE object_table_name = 'aa' AND table_name  = 'user'  



  单键索引：idx_table_name/idx_object_table_name    总体规则就是就近生效原则：
    ① 这种情况生效：【idx_object_table_name】  EXPLAIN SELECT * FROM user_sub_table WHERE object_table_name LIKE 'aa%'   AND table_name  LIKE 'user%'   
    ② 这种情况失效：                           EXPLAIN SELECT * FROM user_sub_table WHERE object_table_name LIKE '%aa'   AND table_name  LIKE '%user'  
    ③ 这种情况生效：【idx_object_table_name】  EXPLAIN SELECT * FROM user_sub_table WHERE object_table_name LIKE 'aa%'   AND table_name  LIKE '%user'  
    ④ 这种情况生效：【idx_table_name】         EXPLAIN SELECT * FROM user_sub_table WHERE object_table_name LIKE '%aa'   AND table_name  LIKE 'user%' 
    ⑤ 这种情况失效：                           EXPLAIN SELECT * FROM user_sub_table WHERE object_table_name LIKE 'aa%' OR table_name  LIKE 'user%'  

    ⑥【table_name】        EXPLAIN SELECT * FROM user_sub_table WHERE table_name = 'aa' AND  object_table_name = 'user'  
    ⑦【object_table_name】 EXPLAIN SELECT * FROM user_sub_table WHERE object_table_name = 'aa' AND table_name  = 'user'  
    ⑧【null】              EXPLAIN SELECT * FROM user_sub_table WHERE object_table_name = 'aa' OR table_name  = 'user'  
    如果出现=号，like也满足条件，那么=号的索引生效
    ⑨【idx_table_name】    EXPLAIN SELECT * FROM user_sub_table WHERE object_table_name LIKE 'aa%' AND table_name  = '%user' 

7.Synchronized 和 ReentrantLock 的区别  深入研究；
  参照代码：\crudreposity实现读写分离和Redis处理（经典）\crudreposity\src\main\java\datacenter\crudreposity\aspect\LockAspect.java

8.list 和 set 的区别，隐身其他集合的深入研究

9.多线程  深入研究  线程重入，重排序等深入研究 Synchronized和Volatile区别，各自深入研究  看视频

10.分库分表怎么分，深入研究？
   分表→ 按时间分：建立一个字典表，把表的配置写入
         比如：id、表名、开始时间、结束时间、要写入的表名
	 user  user_1  user_2  写一个存储过程根据当前系统时间判断需要插入到哪个表
	 然后插入或者更新就可以了。以后查询也是按照这个规则来。
	 配置表：CREATE TABLE `user_sub_table` (
	  `id` bigint(20) NOT NULL AUTO_INCREMENT,
	  `table_name` varchar(20) DEFAULT NULL,
	  `start_time` datetime DEFAULT NULL,
	  `end_time` datetime DEFAULT NULL,
	  `object_table_name` varchar(20) DEFAULT NULL,
	  PRIMARY KEY (`id`)
	) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=latin1

	id     `table_name`  `start_time`             `end_time`             `object_table_name`
	"1	  user	   2018-11-13 16:57:55	   2018-11-15 16:58:06	          user_1"
	"2	  user	   2018-11-16 16:58:19	   2018-11-17 16:58:27	          user_2"

   分库→ 

11.int 和 Integer的区别

12.







